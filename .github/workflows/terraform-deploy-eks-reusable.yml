name: 'Terraform Deploy EKS Reusable'

permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout
  pull-requests: write # This is required to add comments to Pull Requests

on:
  workflow_call:
    secrets:
      AWS_ACCOUNT:
        required: true
      AWS_IAM_ROLE:
        required: true
      WORKLOADS_PAT:
        required: true
    inputs:
      aws-region:
        required: true
        type: string
      s3-bucket:
        required: true
        type: string
      team:
        required: true
        type: string
      environment:
        required: true
        type: string
      deployment-id:
        required: true
        type: string
      cluster-name:
        required: true
        type: string
      load-test-file:
        required: true
        type: string
      sample-app:
        required: true
        type: string

concurrency:
  group: "${{ inputs.team }}-${{ inputs.environment }}-${{ inputs.deployment-id }}"
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  terraform-plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Terraform Plan
      uses: ./.github/actions/terraform-plan
      with:
          AWS_ACCOUNT: ${{ secrets.AWS_ACCOUNT }}
          AWS_IAM_ROLE: ${{ secrets.AWS_IAM_ROLE }}
          WORKLOADS_PAT: ${{ secrets.WORKLOADS_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          deploy: true
          aws-region: ${{ inputs.aws-region }}
          s3-bucket: ${{ inputs.s3-bucket }}
          team: ${{ inputs.team }}
          environment: ${{ inputs.environment }}
          deployment-id: ${{ inputs.deployment-id }}
  terraform-eks-deploy:
    needs: [terraform-plan]
    name: 'Terraform EKS Deploy'
    if: (github.ref_name == 'main' && needs.terraform-plan.outputs.exitcode == 2) ||
          inputs.deployment-id == github.head_ref
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
    - name: Download Plan from S3
      run: |
        aws s3api get-object \
          --bucket ${{ inputs.s3-bucket }} \
          --key ${{ inputs.team }}-${{ inputs.environment }}-${{ steps.tf_args.outputs.CLUSTER_ID }}/tfplan
    - name: Terraform Apply
      run: terraform apply tfplan
    - name: Writing kubeconfig for eks cluster
      run: |
        aws eks update-kubeconfig --name ${{ inputs.cluster-name }} --region ${{ inputs.aws-region }}
    - name: Scale sample deployment
      run: |
        set -xe
        kubectl -n argocd patch applications ${{ inputs.sample-app }} --type='json' -p='[{"op": "replace", "path": "/spec/syncPolicy/automated/selfHeal", "value": false}]'
        kubectl -n ${{ inputs.sample-app }} scale deployment deployment-2048 --replicas=10
        sleep 120
        kubectl -n ${{ inputs.sample-app }} get pods -o wide
        nodes=$(kubectl -n ${{ inputs.sample-app }} get pods -o wide | sed '1d' | awk '{print $7}' | sort | uniq | wc -l)
        echo $nodes
        nodes=$(kubectl -n ${{ inputs.sample-app }} get pods -o wide | sed '1d' | awk '{print $7}' | sort | uniq | wc -l)
        if [ $nodes -ne 10 ]
        then
          exit 1
        else
          exit 0
        fi
    - name: Reset ArgoCD app setting
      if: always()
      run: |
        kubectl -n argocd patch applications ${{ inputs.sample-app }} --type='json' -p='[{"op": "replace", "path": "/spec/syncPolicy/automated/selfHeal", "value": true}]'
    - name: Run local k6 test
      uses: grafana/k6-action@v0.2.0
      with:
        filename: ./tests/${{ inputs.load-test-file }}
